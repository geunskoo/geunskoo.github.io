---
layout: single
title: "[이코테] 실전문제: 두 배열의 원소 교체"
categories: 
    - 알고리즘
tag: [python,정렬]
toc: true
toc_sticky: True
toc_label: "목차"
author_profile: false
sidebar: true
use_math: true
---

# 두 배열의 원소 교체

## 문제

동빈이는 두 개의 배열 A와 B를 가지고 있다. 

두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다

동빈이는 최대 K 번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와
배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말한다.

동빈이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이며, 여러분은 동빈이를 도와야한다.

N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K 번의 바꿔치기 연산을 수행하여 만들 수 있는
배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하라.

예를 들어 N = 5, K = 3이고, 배열 A와 B가 다음과 같다고 하자.

- 배열 A = [1, 2, 5, 4, 3]
- 배열 B = [5, 5, 6, 6, 5]
  이 경우, 다음과 같이 세 번의 연산을 수행할 수 있다.
- 연산 1) 배열 A의 원소 '1'과 배열 B의 원소 '6'을 바꾸기
- 연산 2) 배열 A의 원소 '2'와 배열 B의 원소 '6'을 바꾸기
- 연산 3) 배열 A의 원소 '3'과 배열 B의 원소 '5'를 바꾸기
  세 번의 연산 이후 배열 A와 배열 B의 상태는 다음과 같이 구성될 것이다.
- 배열 A = [6, 6, 5, 4, 5]
- 배열 B = [3, 5, 1, 2, 5]
  이때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수는 없다.

따라서 이 예시의 정답은 26이 된다.

## 입력조건

* 첫 번째 줄: N, K 가 공백으로 구분되어 입력된다. (1 <= N <= 100,000, 0 <= K <= N)
* 두 번째 줄: 배열 A의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000인 자연수이다.
* 세 번째 줄: 배열 B의 원소들이 공백으로 구분되어 입력 된다. 모든 원소는 10,000,000인 자연수이다.



## 출력조건

- 최대 K번 바꿔치기 연산을 수행해서 가장 최대의 합을 갖는 A의 모든 원소 값의 합을 출력



## 입력예시

```python
5 3
1 2 5 4 3
5 5 6 6 5
```

## 출력예시

```python
26
```



## 나의 코드

```python
n,k = map(int,input().split())

A = list(map(int,input().split()))
B = list(map(int,input().split()))

A = sorted(A)
B = sorted(B, reverse = True)

for i in range(k):
    if A[i] < B[i]:
        A[i],B[i] = B[i],A[i]
    else:
        break

sum(A)
```

***>>input***

```python
5 3
1 2 5 4 3
5 5 6 6 5
```

***>>output***

```
26
```

### 🌝 Thinking

백준 브론즈문제를 다 푼 상태여서 비교적 수월하게 구현해냈다.

---

## 답안 예시

```python
n, k = map(int, input().split()) # N과 K를 입력 받기
a = list(map(int, input().split())) # 배열 A의 모든 원소를 입력받기
b = list(map(int, input().split())) # 배열 B의 모든 원소를 입력받기

a.sort() # 배열 A는 오름차순 정렬 수행
b.sort(reverse=True) # 배열 B는 내림차순 정렬 수행

# 첫 번째 인덱스부터 확인하며, 두 배열의 원소를 최대 K번 비교
for i in range(k):
    # A의 원소가 B의 원소보다 작은 경우
    if a[i] < b[i]:
        # 두 원소를 교체
        a[i], b[i] = b[i], a[i]
    else: # A의 원소가 B의 원소보다 크거나 같을 때, 반복문을 탈출
        break

print(sum(a)) # 배열 A의 모든 원소의 합을 출력
```

### 🌝 Thinking

**나의 코드**는 반복구문에 break를 안걸어주었지만

**답안코드**는 break를 걸어 낭비되는 시간 소모를 줄여주었다.



***그래도 전체적인 흐름은 일치함으로 나름 잘 푼 풀이인듯하다😁😊***



## 💡 깨달은 점.

1. N의 크기가 100,000 일때는 최대한 O(n x $logn$) 을 보장하는 알고리즘을 채택해야한다.
1. 리스트의 요소가 리스트이거나 튜플일때도 우선순위를 정하여 정렬을 할 수 있다.


---
**출처**

이것이 코딩 테스트다 - 나동빈 저
{: .notice--info} 
