---
layout: single
title: "[Operating System] 프로세스는 어떻게 다루어지는가?"
categories: 
    - 운영체제
tag: ['운영체제','OS','프로세스']
toc: true
toc_sticky: True
toc_label: "목차"
author_profile: false
sidebar: true
use_math: true
---

# 🚀 프로세스의 관리

## 1️⃣  프로세스

<span style = "color:blue">**프로세스(Process)**</span> : 디스크에서 실행 파일(.exe) 형태로 존재하던 프로그램이 <u>메모리에 올라가서 실행 중인 프로그램</u>이다.

<br/>

<br/>

## 2️⃣  프로세스 상태

> 엄마( 스케줄러 ) : " 나와서 밥(CPU)먹어라!! "
>
> 나 (프로세스) : " 나 게임 중 !!  할 거 없는 형(프로세스) 먼저 줘 ~ "

<span style="font-size:60%"> 밥은 무한리필되는 한 공기... 노잼인 듯ㅋㅋ </span>

<br/>

**[ 프로세스의 상태 변화도 ]**

<img src="../../images/2022-09-03-os-process/image-20220903161218870.png" alt="image-20220903161218870" style="zoom:80%;" /> 

CPU제어권을 아무 프로세스에게 줄 수 없다. 왜냐하면 CPU제어권을 획득하더라도 입출력을 기다리고 있는 프로세스는 아무런 작업을 수행할 수 없다. 이는 CPU자원의 낭비이다. 따라서 프로세스마다 각자의 상태를 정의할 필요가 있다.

<br/>

| 프로세스 상태                                                | 설명                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| <span style = "color:blue">**실행(Running)**</span>          | 프로세스가 CPU제어권을 가지고, 명령을 수행 중인 상태.        |
| <span style = "color:blue">**준비(Ready)**</span>            | CPU만 보유하면 당장 명령을 수행할 수 있는 상태. (다른 조건 모두 충족) |
| <span style = "color:blue">**봉쇄(Blocked, Wait, Sleep)**</span> | CPU제어권을 가지더라도, 명령을 수행할 수 없는 상태.          |
| <span style = "color:blue">**시작(New)**</span>              | 프로세스를 위한 각 종 자료구조는 생성되었지만 메모리는 획득하지 못한 상태. |
| <span style = "color:blue">**완료(Terminated)**</span>       | 프로세스는 종료되었으나, 운영체제가 그 프로세스와 관련된 자료구조를 정리하지 못한 상태. |
| <span style = "color:blue">**중지(Suspended)**</span>        | 외부적인 이유로 프로세스의 수행이 정지된 상태. 메모리를 통째로 빼앗기고 디스크로 스왑 아웃된 상태. |



<br/>

<br/>

## 4️⃣  프로세스의 문맥

 **시분할 시스템 환경**에서는 CPU를 한 프로세스가 독점하는 것을 방지하기 위해 Time Interrupt를 이용하여 CPU제어권을 사용자 프로세스에서 빼앗는다. CPU제어권은 커널에게 넘어가며, 커널은 Ready상태의 프로세스에 CPU를 다시 넘겨준다. 그리고 다시 처음의 프로세스가 CPU제어권을 받으면 명령 수행을 재개한다. 

<br/>

>  CPU : " 그런데 내가.. 어디까지 문제를 풀었더라?  프로세스 문맥을 확인해야겠군..."

<br/>

<span style = "color:blue">**프로세스의 문맥(Process Context)**</span> : 현재 프로세스의 상태를 정확히 규명하기 위한 정보.

<span style="font-size:90%">프로세스 문맥은 아래와 같이 크게 <u>3가지</u>로 분류가능하다.</span>

* **하드웨어 문맥 :** CPU의 수행 상태 정보이다. ( Program counter값, 각 종 Register값 )



* **프로세스의 주소 공간 :** 코드/데이터/스택 로 구성된 프로세스의 독자적인 주소 공간 정보이다.



* **커널상의 문맥 :** 커널 또한 코드/데이터/스택 으로 구성된 커널의 독자적인 주소 공간이 있고, 

  커널의 스택공간에 프로세스를 관리하기 위한 자료구조 **PCB(Process Control Block)**를 뜻한다.

<br/>

<span style = "color:blue">**프로세스 제어 블록(Process Control Block : PCB)**</span> : 운영체제가 시스템내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조.

<img src="../../images/2022-09-03-os-process/image-20220903164014426.png" alt="image-20220903164014426" style="zoom:70%;" />

* 프로그램의 상태
* 프로그램 카운터
* CPU 레지스터 값
* CPU 스케줄링 정보
* 메모리 관리 정보
* 자원 사용 정보
* 입출력 상태 정보

위의 정보를 담는 자료구조.

<br/>

<span style = "color:blue">**문맥교환(Context Switch)**</span> :  현재 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정.

**<span style = "color:#2D3748;background-color:#dcffe4;">사용자모드(프로세스 A) --- 커널모드(Kernel) --- 사용자모드 (프로세스 B)</span>**

<br/>

* **문맥교환이 발생 요인 :** 

  Time Interrupt, System call(I/O)



* **문맥교환의 과정 :**
  1. 프로세스에서 Time Interrupt 및 System call(I/O) 발생.
  2. 사용자 모드에서 커널 모드로 실행 모드 변경. (CPU제어 커널)
  3. 프로세스의 문맥을 PCB에 저장 / 프로세스의 상태가 봉쇄(Blocked)로 변경
  4. 커널이 대기(Ready)상태의 프로세스의 PCB정보를 하드웨에 세팅
  5. 커널모드에서 사용자모드로 실행 모드 변경. (CPU제어 사용자**)**



* **cf. 문맥교환이 아닌 것 :**

  **<span style = "color:#2D3748;background-color:#dcffe4;">사용자모드(프로세스 A) --- 커널모드(Kernel) --- 사용자모드 (프로세스 A)</span>**

  Interrupt, System call을 통해 커널모드의 서비스만 받은 후 복귀하는 경우

<br/>

>  💡**오버헤드** :  어떤 일 처리를 위해 간접적으로 들어가는 시간 및 메모리.
>
> 문맥교환중에 일어나는 작업은 실제 시스템에서 오버헤드가 큼.
>
> 따라서 문맥교환이 빈번하게 발생하지 않도록 CPU할당시간(Time Interrupt)를 늘려야하지만
>
> 너무 크게 세팅하면 시분할 시스템의 의미가 사라진다.

<br/>

<br/>

## 5️⃣ 프로세스 스케줄러

<span style = "color:blue">**스케줄러(scheduler)**</span> : 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드.

* **장기 스케줄러(long term)**

  + 작업 스케줄러라고 하기도함.

  + 시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것 인지를 결정하는 역할.

  + 현대 시분할 시스템에서는 장기스케줄러를 두지 않는 경우가 대부분이다. (메모리 용량이 발전했기 때문)



* **단기 스케줄러(short term)**

  + CPU 스케줄러라고 하기도함.

  + 준비 상태의 프로세스들 중 어떤 프로세스를 다음에 실행할지를 결정하게 된다.



* **중기 스케줄러(medium term)**

  + 너무 많은 프로세스에게 메모리를 할당해 시스템이 저하되는 것을 막기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러.

  + 메모리에 많은 시스템이 올라가 있을 경우, 프로세스중 일부를 선정해 이들의 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장한다.  --- **스왑 아웃(Swap Out)**

    스왑 아웃의 0순위 프로세스는 봉쇄 상태의 프로세스들이다. 그럼에도 불고하고 메모리가 부족한 경우 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑아웃시킴.

    위의[ [프로세스의 상태 변화도](https://geunskoo.github.io/os/os-process/#2%EF%B8%8F%E2%83%A3--%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C) ]그림 을 참고하자!!

<br/>

<br/>

## 6️⃣ 프로세스 생성

<span style = "color:blue">**프로세스 생성 단계**</span>

1. 새로운 프로세스에 **식별자** 할당.
2. 프로세스 정보(PCB)와 주소공간 자료구조 생성.
3. PCB 초기화(프로세스 상태 정보, 프로그램 카운터, 스택, 포인터등의 초기화)
4. 준비 큐에 삽입.



<br/>

<span style = "color:blue">**부모 프로세스 & 자식 프로세스 계층관계**</span>

최초의 프로세스는 운영체제가 직접 생성.

그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성.

<u>프로세스를 생성한 프로세스를 **부모 프로세스**, 그 프로세스에 의해 생성된 프로세스를 **자식 프로세스**라고 한다.</u>

<br/>

<span style = "color:blue">**프로세스 생성 시스템 API**</span>

| 프로세스 생성 시스템 API | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| fork()                   | fork()를 호출한 프로세스와 똑같은 프로세스를 생성함. 식별자를 제외한 모든 문맥을 동일하게 가짐. |
| exec()                   | 프로세스가 지금까지 수행했던 상태를 잊고, 그 주소공간을 완전 새로운 프로그램으로 덮어씌운 후 프로그램의 첫 부분부터 다시 실행을 시작. |
| exit()                   | 운영체제에게 자신이 종료됨을 알림.                           |
| wait()                   | wait()을 호출하면 자식 프로세스가 종료되기를 기다림.         |
| abort()                  | 부모의 프로세스가 자식의 프로세스를 강제로 종료시킴.(비자발적 종료) |

프로세스 생성과 관련된 fork(), exec()등은 특권 명령이다. 시스템콜로 대행 요청해야함.

<br/>

<br/>

## 7️⃣ 프로세스 협력

<span style = "color:blue">**IPC(Inter-Process Communication)**</span> : 실행 중인 서로 다른 프로세스 간에 발생하는 통신과 동기화를 이루기 위한 매커니즘을 말한다.

크게 메세지 전달하는 방식과 공유메모리 방식이 있다.

<br/>

<span style="font-size:120%"><span style = "color:#2D3748;background-color:#dcffe4;">메세지 전달 방식(message passing)</span></span>

두 프로세스의 주소공간이 다르므로 커널이 send(message), receive(message)라는 연산을 제공.

전달하고자는 메세지를 시스템콜을 이용하여 커널이 대신 수행해줌.

1. **직접 통신(direct communication)**

   링크를 정확히 한 쌍의 프로세스에게 할당. 통신하려는 프로세스의 이름을 명시적으로 표시한다.

2. **간접 통신(indirect communication)**

   메세지를 메일박스 또는 포트로 부터 전달 받는다. 메일박스에는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들끼리 통신이 가능하다.



<br/>

<span style="font-size:120%"><span style = "color:#2D3748;background-color:#dcffe4;">공유 메모리 (shared memory)</span></span>

원칙적으로 프로세스의 메모리는 독자적인 공간을 지니고 있으나, 운영체제는 공유메모리를 사용하는 시스템 콜을 지원한다.

서로다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록 한다.

프로세스간의 통신을 수월하게 만들지만 서로의 데이터에 일관성 문제가 유발될 수 있다. (커널이 책임을 지지 않음.)



<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

---

**[ REF ]**

* [운영체제와 정보기술의 원리(이화여자대학교출판문화원) - 개정판 : 반효경 지음]()
* [장장스님의 블로그](https://zangzangs.tistory.com/108)
